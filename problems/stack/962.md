# 962. Maximum Width Ramp

ðŸ” **Iteration 1**

**Pattern:** Monotonic Stack (decreasing indices)  
**Difficulty:** Medium  
**Time:** 15m  
**Solo:** Y optimal

### ðŸ§  Core Logic

*   **The Trick:** Build a stack of **indices** forming a **strictly decreasing** sequence of values from leftâ†’rightâ€”these are the only viable left endpoints. Then scan `j` from **rightâ†’left**; while the top index `i` satisfies `nums[i] â‰¤ nums[j]`, update `maxWidth = max(maxWidth, j - i)` and **pop** (we found the best `j` for that `i`).
*   **Execution:**
    1.  Left pass: for `i = 0â€¦n-1`, **push** `i` if stack empty or `nums[stack.peek()] > nums[i]` (keep it strictly decreasing).
    2.  Right pass: for `j = n-1â€¦0`, while stack nonâ€‘empty and `nums[stack.peek()] â‰¤ nums[j]`, update width and **pop**.
    3.  Return `maxWidth`.
*   **Complexity:**  
    Time `O(N)`  
    Space `O(N)`

### ðŸš¨ Traps & Bugs

*   **Decreasing stack:** Use `>` when building the stack to ensure **strict** decrease; otherwise you can miss wider ramps with duplicates.
*   **Pop condition:** Use `â‰¤` when comparing to allow equal values to form valid ramps.
*   **Data structure:** Prefer `ArrayDeque<Integer>` or an int array as a manual stack over legacy `Stack`.

### ðŸŽ¤ 1â€‘Sentence Pitch

Keep only candidate left endpoints in a **strictly decreasing** stack, then sweep from the right popping all `â‰¤` matches to extract the **widest** ramp in linear time.
