# 394. Decode String

ğŸ” Iteration 1

**Pattern:** Stack / Decoding

**Difficulty:** Medium

**Time:** 20m

**Solo:** Y optimal

### ğŸ§  Core Logic

*   **The Trick:** scan leftâ€‘toâ€‘right, using **two stacks**â€”`countStack` for repeat counts and `resStack` for the **prefix before the current bracket**; at `'['` push state, at `']'` **pop and repeat** the current block, maintaining the invariant: `res` is the decoded string for the **current innermost** context.
*   **Execution:**
    1.  If digit: accumulate full number (handles multiâ€‘digit), then push to `countStack`.
    2.  If `'['`: push current `res` to `resStack`, reset `res = ""`.
    3.  If `']'`: pop `prev = resStack.pop()` and `k = countStack.pop()`, set `res = prev + (res repeated k times)`.
    4.  Else (letter): append to `res`.
    5.  End: `res` is the decoded answer.
*   **Complexity:**

Time `O(N)` (each character processed a constant number of times)

Space `O(N)` (stacks and output)

### ğŸš¨ Traps & Bugs

*   **Edge Case:** **multiâ€‘digit counts** like `"12[a]"`; **nested** patterns like `"3[a2[c]]"`; multiple segments like `"2[abc]3[cd]ef"`.
*   **My Bugs:** first attempt missed stack state transitions; second attempt is correctâ€”one improvement: avoid `res += ch` (creates many strings); prefer a `StringBuilder` for `res` to reduce allocations.

### ğŸ¤ 1-Sentence Pitch

*   â€œUse two stacks to save the **repeat count** and the **prefix** at each `'['`, then rebuild on `']'`â€”linearâ€‘time decoding that naturally handles nesting and multiâ€‘digit counts.â€
