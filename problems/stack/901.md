# 901. Online Stock Span

üîÅ Iteration 1

**Pattern:** Monotonic Stack

**Difficulty:** Medium

**Time:** 15m

**Solo:** N optimal

### üß† Core Logic

*   **The Trick:** keep a **monotonic decreasing stack** of pairs **(price, span)**; for a new `price`, **merge** all previous prices `‚â§ price` by popping and **accumulating their spans**.
*   **Execution:**
    1.  Initialize an empty stack of `(price, span)`.
    2.  For each incoming `price` in `next(price)`:
        1.  set `span = 1`
        2.  while stack not empty **and** `stack.top.price ‚â§ price`:  
            `span += stack.top.span` and `pop()`
        3.  `push(price, span)`
        4.  return `span`
*   **Complexity:**

Time `O(1)` amortized per call (each element is pushed and popped at most once)

Space `O(N)` for `N` calls (stack)

### üö® Traps & Bugs

*   **Edge Case:** **equal prices** should merge (`‚â§` in the while); first call always returns `1`.
*   **My Bugs:** none in final; initially copied solution after recognizing the monotonic pattern. Implementation-wise, using `ArrayDeque<int[]>` is preferred over legacy `Stack`.

### üé§ 1-Sentence Pitch

*   ‚ÄúMaintain a decreasing stack of `(price, span)` and, for each new price, pop and accumulate spans of all prior `‚â§` prices to return the current span in amortized `O(1)`.‚Äù
