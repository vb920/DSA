# 85. Maximal Rectangle

ğŸ” **Iteration 1**

**Pattern:** Perâ€‘row histogram + Monotonic Stack  
**Difficulty:** Hard  
**Time:** 15m  
**Solo:** Y optimal

### ğŸ§  Core Logic

*   **The Trick:** Treat each row as the **base** of a histogram where `count[j]` is the consecutive number of `'1'`s ending at this row. Then the problem reduces to **Largest Rectangle in Histogram** per row; take the maximum over all rows.
*   **Execution:**
    1.  For each row, update `count[j] = matrix[i][j] == '1' ? count[j] + 1 : 0`.
    2.  Run **Largest Rectangle in Histogram** on `count`:
        *   Compute previousâ€‘less (`<`) on the left using a **monotonic increasing stack** (pop while `>=`).
        *   Compute nextâ€‘lessâ€‘orâ€‘equal (`<=`) on the right (pop while `>`).
        *   For each `i`: `width = right[i] - left[i] - 1`, `area = heights[i] * width`, update max.
    3.  Return the global max across rows.
*   **Complexity:**  
    Time `O(R*C)` (each index pushed/popped once per row)  
    Space `O(C)` (stacks + arrays)

### ğŸš¨ Traps & Bugs

*   **Tieâ€‘breaking:** Use `>=` on the **left** and `>` on the **right** (or viceâ€‘versa consistently) to avoid double counting equal heightsâ€”your code does this correctly.
*   **Cleanup:** The `mod` variable is unusedâ€”remove it.
*   **Data structure:** Good use of `ArrayDeque<Integer>`; avoid legacy `Stack`.
*   **Correctness:** Ensure histogram update resets to `0` on `'0'` (you did).
*   **Microâ€‘opt:** You can do histogram LRA in **one pass** with a sentinel `0` height appended to flush the stack (optional; similar complexity).

### ğŸ¤ 1â€‘Sentence Pitch

Build perâ€‘row histograms of consecutive `'1'`s and, for each row, apply the monotonicâ€‘stack histogram algorithm with asymmetric tieâ€‘breaking to get an overall `O(R*C)` optimal solution.
