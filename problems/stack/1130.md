# 1130. Minimum Cost Tree From Leaf Values

ğŸ” Iteration 1

**Pattern:** Monotonic Stack / Greedy

**Difficulty:** Medium

**Time:** 30m

**Solo:** N optimal

### ğŸ§  Core Logic

*   **The Trick:** keep a **monotonic decreasing stack** of leaf values (with a sentinel `+âˆ` at bottom). Whenever the current value `a` is **â‰¥** the stack top `mid`, we **pop `mid`** and pay a cost of  
    `mid * min(nearestGreaterOnLeft, a)`.  
    This is optimal because **`mid` must be multiplied exactly once with one of its first greater neighbors**, and multiplying it by the **smaller** of those two neighbors yields the **least** contribution.
*   **Execution:**
    1.  Push `+âˆ` onto stack as a sentinel.
    2.  For each `a` in `arr`:
        *   While `stack.peek() â‰¤ a`:
            *   `mid = stack.pop()`
            *   Add `mid * min(stack.peek(), a)` to result.
        *   Push `a`.
    3.  Finally, while stack size > 2 (ignore sentinel):
        *   Pop `mid`, add `mid * stack.peek()` (pair the remaining ascending chain).
    4.  Return the accumulated sum.
*   **Complexity:**

Time `O(n)` (each element is pushed and popped at most once)

Space `O(n)` (stack)

### ğŸš¨ Traps & Bugs

*   **Why this works (intuition):**
    *   In the final tree, every leaf value `x` appears in internal node products exactly **once**, multiplied by the **first greater leaf** to its **left or right** (whichever it ends up adjacent to when merges happen).
    *   If `x` has nearest greater neighbors `L` (left) and `R` (right), its contribution must be **`x * min(L, R)`** in any optimal tree; pairing it with the larger neighbor would strictly increase the sum.
    *   The stack enforces this: when you see a value `a` that is â‰¥ the top `mid`, you have found `mid`â€™s right greater neighbor; the remaining stack top is its left neighbor candidate. Paying `mid * min(leftGreater, a)` realizes the minimal forced cost for `mid` and safely removes it from future consideration.
*   **Equal values:** Using `â‰¤` in the while condition ensures equals are resolved immediately and donâ€™t block.
*   **Sentinel `+âˆ`:** Prevents empty-stack checks and guarantees a left â€œgreaterâ€ bound for the first pops.
*   **Overflow:** Problem guarantees the final sum fits in 32-bit; otherwise youâ€™d use `long` for safety.
*   **Data structure:** Prefer `ArrayDeque<Integer>` to legacy `Stack<Integer>` for performance.

### ğŸ¤ 1-Sentence Pitch

*   â€œTreat each leaf as paying exactly once with its nearest greater neighbor; a **decreasing stack** realizes this by popping smaller mids and charging `mid * min(leftGreater, rightGreater)` in **linear time**.â€
