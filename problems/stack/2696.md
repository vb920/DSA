# 2696. Minimum String Length After Removing Substrings

üîÅ **Iteration 1**

**Pattern:** Stack (2‚Äëgram cancellation)  
**Difficulty:** Easy  
**Time:** 8m  
**Solo:** Y optimal

### üß† Core Logic

*   **The Trick:** Maintain a stack so that whenever the top + current char form `"AB"` or `"CD"`, you **pop** (cancel); otherwise **push**. This keeps the string reduced with no pending cancelable pair at the boundary.
*   **Execution:**
    1.  Initialize empty stack/buffer.
    2.  For each `ch` in `s`:
        *   If stack non‚Äëempty and `(top=='A' && ch=='B') || (top=='C' && ch=='D')` ‚Üí **pop**.
        *   Else **push** `ch`.
    3.  Answer is the stack size.
*   **Complexity:**  
    Time `O(N)`  
    Space `O(N)`

### üö® Traps & Bugs

*   **Precedence:** Group the condition to avoid misreads: `if (!empty && ((top=='A'&&ch=='B') || (top=='C'&&ch=='D')))`.
*   **Structure:** Prefer `StringBuilder` (grow/shrink) or `ArrayDeque<Character>` over legacy `Stack`.
*   **Adjacency:** Only adjacent `"AB"`/`"CD"` cancel; stack naturally handles chained deletions.
*   **Empty guard:** Don‚Äôt peek when empty.

### üé§ 1‚ÄëSentence Pitch

Use a stack to cancel `"AB"`/`"CD"` at the frontier so each char is pushed/popped once, yielding a clean `O(N)` solution.
