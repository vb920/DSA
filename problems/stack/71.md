# 71. Simplify Path

ğŸ” Iteration 1

**Pattern:** Stack / Deque

**Difficulty:** Medium

**Time:** 10m

**Solo:** Y optimal

### ğŸ§  Core Logic

*   **The Trick:** treat `"."` as noâ€‘op, `".."` as **pop** (go up one dir), and everything else as a **directory name**; use a stack to build the canonical path and join with slashes.
*   **Execution:**
    1.  split `path` by `'/'` into tokens
    2.  for each token:
        *   if `""` or `"."` â†’ skip
        *   else if `".."` â†’ pop if stack not empty
        *   else â†’ push the token (valid directory/file name, including `"..."`, `"...."`, etc.)
    3.  join stack contents with `'/'` and prepend `'/'`; if stack empty, return `"/"`
*   **Complexity:**

Time `O(N)` (single pass over characters/tokens)

Space `O(N)` (stack of path components)

### ğŸš¨ Traps & Bugs

*   **Edge Case:** multiple slashes (`"//"`) collapse; trailing slashes are ignored; attempts to go above root (`"/../"`) should keep you at `"/"`.
*   **Token semantics:** only `"."` and `".."` are specialâ€”**`"...", "...."` are regular names**, and your code handles this correctly.
*   **Implementation nits:**
    *   Remove debug I/O: `System.out.println(Arrays.toString(components));`
    *   Prefer `ArrayDeque<String>` to legacy `Stack<String>`
    *   You can avoid empty tokens by using `path.split("/+")`, though your `isEmpty()` check already handles them.
*   **My Bugs:** none functionallyâ€”solution is correct and optimal; just drop the debug `println` and consider `Deque` + `String.join`.

### ğŸ¤ 1-Sentence Pitch

*   â€œScan tokens once, pushing names and popping on `'..'`, then join the stack with `'/'`â€”a clean `O(N)` canonicalization.â€
