## 3174 . Clear Digits (Backspace-on-Digit)

**Iteration:** 1  
**Pattern:** Stack simulation / Backspace-like (prefix invariant)  
**Difficulty:** Easy  
**Time:** 7m  
**Solo:** **Optimal** (linear scan + stack/buffer; asymptotically optimal)

***

### Core Logic

*   **The Trick:**  
    Maintain the invariant: **after processing the first *i* characters, the stack equals the final string formed from `s[0..i]` if digits delete the immediately preceding kept character**.
    *   When you see a **letter**, it survives *for now* ⇒ push.
    *   When you see a **digit**, it **deletes exactly one previous kept letter** (if any) ⇒ pop.  
        This mirrors the backspace-string pattern; stack (or a grow/shrink buffer) precisely models this one-step cancellation.

*   **Execution:**
    *   Iterate over `s`.
    *   If `ch` is a digit: `pop` if stack not empty.
    *   Else: `push(ch)`.
    *   At the end, read characters from the stack in order.

*   **Complexity:**
    *   **Time:** `O(n)` (each char pushed/popped at most once).
    *   **Space:** `O(n)` in worst case (all letters).

***

### Traps & Bugs

*   **Empty pop:** Guard `st.isEmpty()` before `pop` (you did).
*   **Unicode digits:** `Character.isDigit` matches Unicode digits, not just `'0'..'9'`. If the problem means only ASCII digits, use `ch >= '0' && ch <= '9'`.
*   **Java `Stack` vs `Deque`:** `Stack` is legacy & synchronized; prefer `ArrayDeque<Character>` or, better, a **mutable buffer** (`StringBuilder` with `setLength(len-1)`) to avoid boxing overhead for `Character`.
*   **Consecutive digits at start:** Should be no-ops (nothing to delete).
*   **Large input:** Avoid repeated string concatenations; your `StringBuilder` at the end is correct.

***

### 1‑Sentence Pitch

Simulate “digits delete the previous kept letter” with a stack/buffer so each character is processed once, giving linear time and space.

***