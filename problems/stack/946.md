# 946. Validate Stack Sequences

üîÅ Iteration 1

**Pattern:** Stack / Simulation

**Difficulty:** Medium

**Time:** 5m

**Solo:** Y optimal

### üß† Core Logic

*   **The Trick:** simulate the push/pop process with a stack; **push each `pushed[i]`**, and while the **top equals `popped[idx]`**, **pop** and advance `idx`. If all pops can be matched this way, the sequence is valid.
*   **Execution:**
    1.  initialize empty stack and `idx = 0` for the next value to pop
    2.  for each `x` in `pushed`:  
        a) `push(x)`  
        b) while stack not empty **and** `stack.peek() == popped[idx]`: `pop()`, `idx++`
    3.  return `stack.isEmpty()` (all pushes got legally popped)
*   **Complexity:**

Time `O(n)` (each element pushed and popped at most once)

Space `O(n)` (stack in worst case)

### üö® Traps & Bugs

*   **Index guard:** it's safe as written given equal lengths, but adding `idx < popped.length` in the `while` condition is a clean guard.
*   **Data structure:** prefer `ArrayDeque<Integer>` over legacy `Stack<Integer>` for stack behavior.
*   **Duplicates:** works fine‚Äîcomparison is by value, not identity.
*   **Invariant:** after processing any prefix of `pushed`, the stack contains **exactly** those items not yet matched against the next `popped[idx]`.

### üé§ 1-Sentence Pitch

*   ‚ÄúGreedily push from `pushed` and pop whenever the top matches the next target in `popped`; if you can empty the stack, the sequences are a valid stack simulation in `O(n)`.‚Äù
