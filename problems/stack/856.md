# 856. Score of Parentheses

ğŸ” **Iteration 1**

**Pattern:** Stack frames (parenthesis evaluation)  
**Difficulty:** Medium  
**Time:** 15m  
**Solo:** Y better

### ğŸ§  Core Logic

*   **The Trick:** Treat each `'('` as starting a **new scoring frame**. Push the **outer** score onto a stack and reset the **current** score to `0` to accumulate the inner score. When you see `')'`, there are two cases:
    *   If the inner was empty (`()`), then its score is **1**.
    *   If there was content `A` inside (`(A)`), the rules say its score is **2 Ã— score(A)** â†’ this is the `2 * currentScore` you saw.
        Finally, merge with the outer frame: `currentScore = poppedOuter + max(2*inner, 1)`.
*   **Execution:**
    1.  `current = 0`, empty stack.
    2.  For each char:
        *   `'('`: `push(current)`, `current = 0`.
        *   `')'`: `outer = pop()`, `current = outer + (current == 0 ? 1 : 2 * current)`.
    3.  Return `current`.
*   **Complexity:**  
    Time `O(N)`  
    Space `O(N)`

### ğŸš¨ Traps & Bugs

*   **Why `2 * inner`:** Only when closing a nonâ€‘empty frame `(A)`â€”the problemâ€™s rule doubles nested content; `()` is the base case `1`. Using `max(2*inner,1)` compactly encodes both.
*   **Data structure:** Prefer `ArrayDeque<Integer>` over legacy `Stack`.
*   **Robustness:** Input is balanced for LC 856, but guard `pop()` if reusing elsewhere.

### ğŸ¤ 1â€‘Sentence Pitch

Use a **frame-score stack**: push on `'('`, and on `')'` either score `()` as `1` or double the inner score for `(A)`, then add back to the outerâ€”one linear pass, clean and correct.
