# 84. Largest Rectangle in Histogram

ğŸ” **Iteration 1**

**Pattern:** Monotonic Stack (Prevâ€‘Less / Nextâ€‘Lessâ€‘orâ€‘Equal)  
**Difficulty:** Hard  
**Time:** 15m  
**Solo:** Y optimal

### ğŸ§  Core Logic

*   **The Trick:** For each bar `i`, find how far it can expand left/right while remaining the **minimum height** in that span. Compute:
    *   `left[i]` = index of **previous strictly smaller** bar (`<`)
    *   `right[i]` = index of **next smallerâ€‘orâ€‘equal** bar (`<=`)  
        Using asymmetric ties (`>=` on the left pass, `>` on the right pass) ensures duplicates are counted exactly once.
*   **Execution:**
    1.  **Left pass (0â†’nâ€‘1):** maintain increasing stack of indices; `pop` while `heights[stk.peek()] >= heights[i]`; set `left[i] = stk.peek()` or `-1`; `push(i)`.
    2.  **Right pass (nâ€‘1â†’0):** clear stack; `pop` while `heights[stk.peek()] > heights[i]`; set `right[i] = stk.peek()` or `n`; `push(i)`.
    3.  For each `i`: `width = right[i] - left[i] - 1`, `area = heights[i] * width`, track max.
*   **Complexity:**  
    Time `O(N)`  
    Space `O(N)`

### ğŸš¨ Traps & Bugs

*   **Tieâ€‘breaking matters:** Use `>=` on left and `>` on right (or the opposite consistently) to avoid double counting equal heights.
*   **No modulus needed:** Remove the `mod` variableâ€”this problem doesnâ€™t require modulo arithmetic.
*   **Overflow safety:** If constraints grow, compute area in `long` before `Math.max`.
*   **Stack hygiene:** Clear between passes; store **indices**, not values.
*   **Alternative:** Singleâ€‘pass sentinel trickâ€”append a `0` height and flush the stack.

### ğŸ¤ 1â€‘Sentence Pitch

Find each barâ€™s maximal span with two monotonic scans (strict on one side, nonâ€‘strict on the other) and take `height Ã— width` per bar for an `O(N)` maximum.
