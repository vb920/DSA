# 1475. Final Prices With a Special Discount in a Shop

ğŸ” Iteration 1

**Pattern:** Monotonic Stack

**Difficulty:** Easy

**Time:** 10m

**Solo:** Y optimal

### ğŸ§  Core Logic

*   **The Trick:** scan from **right to left** maintaining a **monotonic non-decreasing stack** of prices; for each `prices[i]`, the top of the stack after popping all greater elements is the **next â‰¤ price** to its rightâ€”the discount.
*   **Execution:**
    1.  initialize an empty stack `st`
    2.  iterate `i = n-1 â€¦ 0`:
        1.  **pop** while `st.peek() > prices[i]` (we only want the next `â‰¤`)
        2.  the discount is `st.peek()` if stack non-empty, else `0`
        3.  record `final[i] = prices[i] - discount`
        4.  **push** `prices[i]` onto the stack
    3.  return the final prices array
*   **Complexity:**

Time `O(n)`

Space `O(n)` (stack)

### ğŸš¨ Traps & Bugs

*   **Edge Case:** duplicates work because we keep `â‰¤` (we pop only `>`), so the next equal price qualifies as a discount.
*   **My Bugs:** none functionallyâ€”your logic is correct and linear. Minor polish:
    *   you can avoid building `v` + `reverse` by writing directly to `ans[i]` during the right-to-left pass
    *   prefer `ArrayDeque<Integer>` over legacy `Stack<Integer>`
    *   the three `if/else-if` branches can be simplified to a single while-pop + one check.

### ğŸ¤ 1-Sentence Pitch

*   â€œUse a right-to-left **monotonic stack** so each item finds its next â‰¤ neighbor in **amortized O(1)**, yielding an overall **O(n)** solution far better than the `O(nÂ²)` brute force.â€
