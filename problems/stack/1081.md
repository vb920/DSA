# 1081. Smallest Subsequence of Distinct Characters

ğŸ” Iteration 1

**Pattern:** Greedy + Monotonic Stack

**Difficulty:** Medium

**Time:** 15m

**Solo:** N optimal

### ğŸ§  Core Logic

*   **The Trick:** keep a **stack of chosen chars** forming the current answer; for each char `ch`, if itâ€™s **not already used**, **pop** larger chars from the stack **only if** they **appear later again** (tracked by remaining frequency). This keeps the subsequence **lexicographically smallest** while ensuring **each character appears once**.
*   **Execution:**
    1.  Count remaining occurrences `freq[26]` for all chars.
    2.  Maintain `inStack` (visited) to avoid duplicates and a stack for the result.
    3.  For each `ch` in `s`:
        *   Decrement `freq[ch]` (one fewer remaining).
        *   If `inStack[ch]` â†’ **continue** (already included).
        *   While stack not empty **and** `stack.peek() > ch` **and** `freq[stack.peek()] > 0`, **pop** and mark popped char as not in stack.
        *   **Push** `ch` and mark `inStack[ch] = true`.
    4.  Join stack into the final string (bottomâ†’top order).
*   **Complexity:**

Time `O(n)` (each char pushed/popped at most once)

Space `O(n)` stack; `O(26)` for counts/visited

### ğŸš¨ Traps & Bugs

*   **Pop condition:** pop **only if** top `>` `ch` **and** it **appears later** (`freq[top] > 0`). If `freq[top] == 0`, popping would lose that character forever.
*   **Visited guard:** always **skip** adding `ch` if itâ€™s already in the stack to enforce distinctness.
*   **Decrement timing:** **decrement \`freq\[ch] before decisions** so â€œappears laterâ€ is accurate.
*   **Alphabet assumption:** typical constraints are lowercase `aâ€“z`; for larger alphabets, size arrays accordingly (or use maps).
*   **Implementation nits:** `boolean[26] inStack` is faster than `HashSet<Character>`; prefer `ArrayDeque<Character>` over legacy `Stack<Character>`.

### ğŸ¤ 1-Sentence Pitch

*   â€œGreedily build a unique-character subsequence with a **monotonic stack**, popping larger letters **only if they reappear later**, to get the **lexicographically smallest** result in linear time.â€
