# 150. Evaluate Reverse Polish Notation

ğŸ” Iteration 1

**Pattern:** Stack

**Difficulty:** Medium

**Time:** 15m

**Solo:** N optimal

### ğŸ§  Core Logic

*   **The Trick:** scan tokens leftâ€‘toâ€‘right, **push operands**; on an operator, **pop the top two** (note the order: `first = pop2`, `second = pop1`), **apply op**, and **push result** back.
*   **Execution:**
    1.  initialize an empty stack
    2.  for each token:
        *   if itâ€™s a number â†’ **push** it
        *   if itâ€™s an operator (`+`, `-`, `*`, `/`) â†’ **pop** `b = top`, then **pop** `a = next`, compute `a op b`, **push** result
    3.  at the end, the stackâ€™s single element is the answer; **return** it
*   **Complexity:**

Time `O(N)` (each token processed once)

Space `O(N)` (stack for operands)

### ğŸš¨ Traps & Bugs

*   **Operand order:** for `-` and `/`, use **`a = first popped` (left), `b = second popped` (right)**, then compute `a - b`, `a / b`
*   **Division semantics (Java/LeetCode):** integer division **truncates toward zero**; this matches the problemâ€™s requirement
*   **Token parsing:** prefer a **`Stack<Integer>` (or `ArrayDeque<Integer>`)** to avoid repeated `parseInt`/`String` conversions
*   **Validation:** in production code, check for **insufficient operands** and ensure final stack size is **1** (LeetCode inputs are valid)
*   **Negative numbers:** tokens like `"-11"` are numbers, **not** the `-` operatorâ€”your operator check with `equals("-")` correctly distinguishes this
*   **Overflow:** intermediate `*` or `+` can overflow 32â€‘bit `int`; LeetCode datasets stay within bounds, but be aware

### ğŸ¤ 1-Sentence Pitch

*   â€œUse a stack: push numbers, and on each operator pop two, compute, and push backâ€”single pass `O(N)` with minimal state and correct operand order.â€
