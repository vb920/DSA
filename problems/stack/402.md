# 402. Remove K Digits

ğŸ” Iteration 1

**Pattern:** Greedy / Monotonic Stack

**Difficulty:** Medium

**Time:** 20m

**Solo:** N optimal

### ğŸ§  Core Logic

*   **The Trick:** maintain a **monotonic increasing stack of digits**; for each digit, **pop larger previous digits** while `k > 0` to achieve the smallest lexicographic (and numeric) result; if `k` remains, remove from the **end**; strip leading zeros.
*   **Execution:**
    1.  If `k == num.length()` â†’ return `"0"`.
    2.  Scan leftâ†’right; for each digit `d`:
        *   while `k > 0`, stack not empty, and `stack.peek() > d`, **pop** and `k--`.
        *   **push** `d`.
    3.  If `k > 0` after the scan, **pop** the last `k` digits (theyâ€™re the largest trailing digits).
    4.  Build string from stack (reverse if you popped into a builder).
    5.  **Remove leading zeros**; if empty, return `"0"`, else return the result.
*   **Complexity:**

Time `O(n)`

Space `O(n)`

### ğŸš¨ Traps & Bugs

*   **Residual `k`:** must pop from the **end** if `k` still > 0 after the main loop.
*   **Leading zeros:** ensure trimming; result can become empty â†’ return `"0"`.
*   **Stack choice:** prefer `ArrayDeque<Character>` over legacy `Stack` for speed; keep digits as `char` (no `BigInteger`).
*   **Invariant:** the stack remains **nondecreasing**; any larger left digit that can be removed (with remaining `k`) is popped to minimize the number.

### ğŸ¤ 1-Sentence Pitch

*   â€œGreedily keep an **increasing stack** and delete left-side larger digits first; if any deletions remain, trim from the endâ€”yielding the smallest number in linear time.â€
