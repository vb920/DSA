# 1598. Crawler Log Folder

ğŸ” Iteration 1

**Pattern:** Stack / Counter

**Difficulty:** Easy

**Time:** 7m

**Solo:** Y better

### ğŸ§  Core Logic

*   **The Trick:** treat logs as **moves in a directory tree**â€”`"./"` is a noâ€‘op, `"../"` moves **up one** if possible, and `"x/"` moves **down one**; you only need the **final depth**
*   **Execution:**
    1.  scan each log entry
    2.  if `"./"` â†’ do nothing
    3.  if `"../"` â†’ pop once if stack not empty (or `depth = max(0, depth - 1)`)
    4.  else (a directory like `"abc/"`) â†’ push it (or `depth++`)
    5.  answer is the **stack size** (or just `depth`)
*   **Complexity:**

Time `O(n)` (one pass over logs)

Space `O(n)` with stack (optimal is **`O(1)`** using an integer `depth`)

### ğŸš¨ Traps & Bugs

*   **Edge Case:** attempts to go above root (`"../"` when empty) should be ignoredâ€”your code handles this
*   **Token semantics:** only `"./"` and `"../"` are special; any other token ending with `'/'` is a directory name (length can be > 1)
*   **Unnecessary storage:** since only the **count** matters, a simple `depth` counter is **optimal space**; stack is fine but not needed
*   **Data structure nit:** if you keep a stack, prefer `ArrayDeque<String>` over legacy `Stack<String>` in Java

### ğŸ¤ 1-Sentence Pitch

*   â€œWalk the logs and maintain the current depthâ€”increment on dir, decrement on `'../'` (bounded at zero); the final depth is the answer, so a simple counter is optimal.â€
