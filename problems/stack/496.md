# 496. Next Greater Element I

ğŸ” Iteration 1

**Pattern:** Monotonic Stack + Hashing

**Difficulty:** Easy

**Time:** 10m

**Solo:** Y optimal

### ğŸ§  Core Logic

*   **The Trick:** scan `nums2` **right â†’ left** with a **monotonic decreasing stack** so the top is the **next strictly greater** element after popping all `â‰¤` values; store `value â†’ nextGreater` in a map, then answer queries for `nums1`.
*   **Execution:**
    1.  Initialize empty stack `st` and map `next[val]`.
    2.  For `i = n2-1 â€¦ 0`:
        *   While `st` not empty **and** `st.peek() â‰¤ nums2[i]`, `pop()`.
        *   The next greater is `st.peek()` if present, else `-1`; set `next[nums2[i]]`.
        *   `push(nums2[i])`.
    3.  For each `x` in `nums1`, output `next[x]`.
*   **Complexity:**

Time `O(n2 + n1)` (each element pushed/popped at most once; lookups `O(1)`)

Space `O(n2)` (stack + map)

### ğŸš¨ Traps & Bugs

*   **Strictly greater vs. â‰¥:** pop while `â‰¤` to ensure the remaining top is **strictly** greater (you used `<=`, correct).
*   **Distinctness assumption:** This mapping by **value** relies on `nums2` having **distinct elements** (true for LC 496). If duplicates existed, youâ€™d need index-based processing.
*   **Simplify branches:** The three `if/else` branches can be reduced to: **while-pop**, then one check for empty vs. peek.
*   **Data structure:** Prefer `ArrayDeque<Integer>` over legacy `Stack<Integer>` in Java for stack behavior.
*   **Safety:** Accessing `mp.get(el)` is safe since `nums1` is guaranteed to be a subset of `nums2`.

### ğŸ¤ 1-Sentence Pitch

*   â€œCompute each `nums2` elementâ€™s next strictly greater with a right-to-left **monotonic decreasing stack**, then answer `nums1` by hash lookupâ€”linear time and space.â€
