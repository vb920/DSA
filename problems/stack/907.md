# 907. Sum of Subarray Minimums

ğŸ” **Iteration 1**

**Pattern:** Monotonic Stack (Previousâ€‘Less / Nextâ€‘Less)  
**Difficulty:** Medium  
**Time:** 20m  
**Solo:** Y optimal

### ğŸ§  Core Logic

*   **The Trick:** Each `arr[i]` is the **minimum** for exactly `(i - left[i]) * (right[i] - i)` subarrays, where:
    *   `left[i]` = index of the **previous strictly smaller** element to the left,
    *   `right[i]` = index of the **next smallerâ€‘orâ€‘equal** element to the right.  
        The **asymmetric ties** ( `<` on the left, `<=` on the right) ensure **duplicates are counted once** (tieâ€‘break to the right).
*   **Execution:**
    1.  **Left pass (i = 0 â†’ nâ€‘1):** maintain **increasing** stack of indices; `pop` while `arr[top] >= arr[i]`; then `left[i] = top or -1`; `push(i)`.
    2.  **Right pass (i = nâ€‘1 â†’ 0):** clear stack; maintain **increasing** stack; `pop` while `arr[top] > arr[i]`; then `right[i] = top or n`; `push(i)`.
    3.  Contribution: `ans += (long)(i - left[i]) * (right[i] - i) % MOD * arr[i] % MOD`.
*   **Complexity:**  
    Time `O(N)` (each index pushed/popped â‰¤ 1 per pass)  
    Space `O(N)`

### ğŸš¨ Traps & Bugs

*   **Tieâ€‘breaking matters:** Use `>=` on the **left** and `>` on the **right** (or **viceâ€‘versa** consistently) to avoid double counting when values are equal.
*   **Bounds:** Initialize `left[i] = -1`, `right[i] = n` for â€œno smaller found.â€
*   **Overflow:** Cast to `long` before products; mod at each step: `(((((i-L)*(R-i))%MOD)*arr[i])%MOD)`.
*   **Stack hygiene:** `stk.clear()` between passes; stack holds **indices**, not values.

### ğŸ¤ 1â€‘Sentence Pitch

Compute each elementâ€™s span as the unique minimum via two monotonic stacks (strict on one side, nonâ€‘strict on the other), then sum contributions in linear time.
