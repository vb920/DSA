# 503. Next Greater Element II

ğŸ” Iteration 1

**Pattern:** Monotonic Stack (circular)

**Difficulty:** Medium

**Time:** 20m

**Solo:** Y optimal

### ğŸ§  Core Logic

*   **The Trick:** simulate circularity by scanning **from right to left twice** (`i = 2n-1 â†’ 0`) with a **monotonic decreasing stack** (keep only candidates strictly greater than current); write answers only when `i < n`.
*   **Execution:**
    1.  let `n = nums.length`, create `ans[n]`, and an empty stack `st` of values
    2.  for `i = 2n-1 â€¦ 0`:
        *   while `st` not empty **and** `st.peek() â‰¤ nums[i % n]`, **pop**
        *   if `i < n`, set `ans[i] = st.empty ? -1 : st.peek()`
        *   **push** `nums[i % n]`
    3.  return `ans`
*   **Complexity:**

Time `O(n)` (each element pushed/popped â‰¤ 1â€“2 times)

Space `O(n)` (stack)

### ğŸš¨ Traps & Bugs

*   **Circular wrap:** iterate **`2n`** steps and use `i % n` for value access; **only write** when `i < n`.  
    (Your solution built a list `v` and reversedâ€”works but can be simplified via the `i < n` check.)
*   **Strictness:** problem asks for **next strictly greater** â†’ pop while **`â‰¤`** (you did this).
*   **Duplicates:** storing **values** (not indices) in the stack is fine here since we only need the next **value**; avoid valueâ†’answer maps (theyâ€™d break with duplicates).
*   **Data structure:** prefer `ArrayDeque<Integer>` over legacy `Stack<Integer>` for stack behavior and speed.
*   **Space nit:** you can write `ans[i]` directly (skip building `v` + `reverse`) for cleaner `O(n)` memory.

### ğŸ¤ 1-Sentence Pitch

*   â€œHandle wrapâ€‘around by scanning **twice** rightâ€‘toâ€‘left with a **decreasing stack**; after popping all `â‰¤` values, the top is the next greaterâ€”fill answers only for the first pass.â€
