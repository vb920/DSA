# 1544. Make The String Great

ğŸ” **Iteration 1**

**Pattern:** Stack (adjacent oppositeâ€‘case cancellation)  
**Difficulty:** Easy  
**Time:** 10m  
**Solo:** Y optimal

### ğŸ§  Core Logic

*   **The Trick:** Adjacent letters cancel if theyâ€™re the **same alphabet** with **opposite case**â€”i.e., `abs(top - ch) == 32` for ASCII letters. Maintain a stack so when the incoming `ch` with the top forms such a pair, **pop**; else **push**. This keeps the string reduced with no pending bad adjacent pair.
*   **Execution:**
    1.  Initialize empty stack/buffer.
    2.  For each `ch` in `s`:
        *   If stack nonâ€‘empty and `abs(top - ch) == 32` â†’ **pop**.
        *   Else **push** `ch`.
    3.  Return the stack content (reverse if you used `push`/`pop` order).
*   **Complexity:**  
    Time `O(N)`  
    Space `O(N)`

### ğŸš¨ Traps & Bugs

*   **Condition clarity:** Group checks to avoid duplicate `isEmpty` and precedence pitfalls.
*   **Data structure:** Prefer `ArrayDeque<Character>` or a `StringBuilder` grow/shrink buffer over legacy `Stack`.
*   **Assumptions:** `abs(diff)==32` works because input is guaranteed **English letters**; otherwise use caseâ€‘insensitive compare like `Character.toLowerCase(top)==Character.toLowerCase(ch) && top!=ch`.
*   **Order:** If pushing to the front (stack), remember to **reverse** at the end.

### ğŸ¤ 1â€‘Sentence Pitch

Use a stack to cancel adjacent oppositeâ€‘case pairs on the fly so each character is pushed/popped at most once, producing the unique reduced string in linear time.
