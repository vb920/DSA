# 3. Longest Substring Without Repeating Characters

ğŸ” Iteration 1

**Pattern:** Sliding Window + Hashing (lastâ€‘seen index)

**Difficulty:** Medium

**Time:** 8m

**Solo:** N â€” missed the lastâ€‘seen trick; initial attempt incorrect

### ğŸ§  Core Logic

*   **The Trick:** keep a moving window `[l..r]` and a map of **last seen index per char**; when you see a repeat at `r`, **jump `l` to `max(l, last[c] + 1)`** to keep the window duplicateâ€‘free
*   **Execution:**
    1.  initialize `l = 0`, `maxLen = 0`, map `lastIdx`
    2.  for each `r` from `0..n-1` with char `c = s[r]`:
    3.  if `c` seen before at `lastIdx[c]`, set `l = max(l, lastIdx[c] + 1)` (donâ€™t move left backward)
    4.  update `lastIdx[c] = r`
    5.  update `maxLen = max(maxLen, r - l + 1)`
*   **Complexity:**

Time `O(n)`

Space `O(min(n, Î£))` (distinct chars in window)

### ğŸš¨ Traps & Bugs

*   **Edge Case:** empty string â†’ `0`; single char â†’ `1`
*   **My Bugs:** using only a `Set` and doing `length++` or `length = 1` on duplicates is incorrectâ€”must **shrink from left** (or jump via lastâ€‘seen) to remove the previous occurrence; also tracking `length` independently is errorâ€‘proneâ€”prefer `r - l + 1` derived from window bounds

### ğŸ¤ 1-Sentence Pitch

*   â€œSlide a window while tracking each characterâ€™s last index; on a repeat, jump the left bound past the previous occurrence to maintain a duplicateâ€‘free window in `O(n)`.â€
