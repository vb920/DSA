# 49. Group Anagrams

ğŸ” Iteration 1

**Pattern:** Hashing / Canonicalization

**Difficulty:** Medium

**Time:**  10 m

**Solo:** N â€” needed the sortingâ€‘key insight

### ğŸ§  Core Logic

*   **The Trick:** map each word to a **canonical signature** so all anagrams share the **same key** (e.g., **sorted characters** or a **26â€‘count vector**); group by this key
*   **Execution:**
    1.  for each `word` in `strs`
    2.  compute its **signature**
        *   option A (simple): `char[] c = word.toCharArray(); Arrays.sort(c); key = new String(c)`
        *   option B (faster for aâ€“z): build lengthâ€‘26 counts and encode as key (e.g., `#1#0#2...`)
    3.  push `word` into `map.get(key)` list (create list if missing)
    4.  return all `map.values()` as the grouped anagrams
*   **Complexity:**

Time `O(N Â· L log L)` with sorting key (N = #words, L = avg word length)  
or `O(N Â· L)` with 26â€‘count key

Space `O(N Â· L)` for storing groups & keys (countâ€‘key reduces constant factors)

### ğŸš¨ Traps & Bugs

*   **Edge Case:** empty strings `""` should group together; mixed case or nonâ€‘aâ€“z requires either sorting key or a larger count vector
*   **My Bugs:** stuck on the **canonical key idea**â€”needed to (1) sort chars and use a **new String** as key (arrays arenâ€™t valid map keys), or (2) build a stable 26â€‘count signature; also missed that **all anagrams map to the exact same key**, which is why grouping is trivial once the key is right

### ğŸ¤ 1-Sentence Pitch

*   â€œCanonicalize each word (sorted chars or 26â€‘count signature) and hash to listsâ€”anagrams collide on the same key, so grouping becomes a single pass.â€
