# 347. Top K Frequent Elements

ğŸ” Iteration 1

**Pattern:** Hashing + Heap (Priority Queue)

**Difficulty:** Medium

**Time:** 8m

**Solo:** Y optimal

### ğŸ§  Core Logic

*   **The Trick:** count frequencies, then **heapâ€‘select** the `k` highestâ€‘frequency elements
*   **Execution:**
    1.  build a frequency map `val â†’ count`
    2.  push all `(val, count)` into a **maxâ€‘heap** ordered by count
    3.  pop `k` times, collecting the keys into `ans`
    4.  return `ans`
*   **Complexity:**

Time `O(n + m log m)` where `m` = #distinct elements

Space `O(m)`

### ğŸš¨ Traps & Bugs

*   **Edge Case:** ensure `k â‰¤` distinct elements; negatives/zeros fine; if `k == 0` â†’ empty result
*   **My Bugs:** none in logic; minorâ€”prefer `Integer.compare(b.getValue(), a.getValue())` over `b.getValue() - a.getValue()` to avoid overflow; **alternatives** to remember next time:
    *   **Minâ€‘heap of size k:** `O(n log k)` time, `O(m)` space (better when `k << m`)
    *   **Bucket sort:** group values by frequency (index = count) â†’ **`O(n)`** time, `O(n)` space
    *   **Quickselect on counts:** average **`O(n)`** time to find the kâ€‘th frequency threshold

### ğŸ¤ 1-Sentence Pitch

*   â€œHash counts, then use a heap to pop the topâ€‘`k` frequenciesâ€”clean `O(n + m log m)`; for even faster constants, use minâ€‘heap(k) or bucket sort.â€
