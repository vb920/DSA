# 242. Valid Anagram

ğŸ” Iteration 1

**Pattern:** Hashing / Frequency Counting

**Difficulty:** Easy

**Time:** 4m

**Solo:** Y optimal

### ğŸ§  Core Logic

*   **The Trick:** compare **character frequency counts**â€”two strings are anagrams iff their **multiset of chars** match
*   **Execution:**
    1.  build a frequency map for `s` and for `t`
    2.  compare the two maps for equality
    3.  (microâ€‘opt) earlyâ€‘exit if `s.length() != t.length()`
*   **Complexity:**

Time `O(n)` (single pass per string; hash lookups are O(1) average)

Space `O(k)` (number of distinct characters; `O(1)` if restricted to lowercase aâ€“z via fixed array)

### ğŸš¨ Traps & Bugs

*   **Edge Case:** unequal lengths â†’ immediately `false`; Unicode followâ€‘up needs a map (array of 26 works only for lowercase English)
*   **My Bugs:** none; logic correctâ€”could reduce constant factors with a **single map** (inc for `s`, dec for `t`, validate zeros) and add an **early length check**

### ğŸ¤ 1-Sentence Pitch

*   â€œCount characters and compare frequenciesâ€”linear time, linear (distinct) space; strictly better than sortingâ€™s `O(n log n)` and optimal since you must read all chars.â€
s