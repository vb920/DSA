# 205. Isomorphic Strings

ğŸ” Iteration 1

**Pattern:** Hashing / Bijection

**Difficulty:** Easy

**Time:** 8m

**Solo:** N â€” first tried forward map only

### ğŸ§  Core Logic

*   **The Trick:** enforce a **bijection** (oneâ€‘toâ€‘one) between `s` and `t` using **two maps** (`sâ†’t` and `tâ†’s`) so no character maps to two different targets (and vice versa).
*   **Execution:**
    1.  if `s.length() != t.length()` â†’ return `false`
    2.  for each index `i`:
        *   let `a = s.charAt(i)`, `b = t.charAt(i)`
        *   if `a` already mapped, it **must equal** `b`; else set `a â†’ b`
        *   if `b` already mapped back, it **must equal** `a`; else set `b â†’ a`
    3.  if no conflict arises, return `true`
*   **Complexity:**

Time `O(n)`

Space `O(k)` (distinct chars; bounded by alphabet size)

### ğŸš¨ Traps & Bugs

*   **Edge Case:** unequal lengths â†’ `false`; repeated chars must map consistently both ways; works for any char values (ASCII/Unicode)
*   **My Bugs:** first submission had **only forward map**, allowing two different `s` chars to collide onto the same `t` char; adding the **reverse map** fixed it; also consider adding the **length check** upfront

### ğŸ¤ 1-Sentence Pitch

*   â€œCheck a strict oneâ€‘toâ€‘one mapping with **two hash maps** so each side maps uniquelyâ€”single pass `O(n)` correctness.â€
