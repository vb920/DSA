# 2405. Optimal Partition of String

ğŸ” Iteration 1

**Pattern:** Greedy + Hashing (Bitmask/Set)

**Difficulty:** Medium

**Time:** 25m

**Solo:** N â€” needed the greedy reset-on-repeat trick

### ğŸ§  Core Logic

*   **The Trick:** keep a **presence mask** for the current substring; **start a new substring** (increment count and reset mask) **as soon as a character would repeat**, then mark it
*   **Execution:**
    1.  initialize `ans = 1` (at least one substring if `s` non-empty), `mask = 0`
    2.  for each character `c` in `s`:
        1.  `bit = 1 << (c - 'a')`
        2.  if `(mask & bit) != 0` â†’ repeated in current block â‡’ `ans++`, `mask = 0`
        3.  set `mask |= bit`
    3.  return `ans`
*   **Complexity:**

Time `O(N)`

Space `O(1)` (bitmask for 26 lowercase letters)

### ğŸš¨ Traps & Bugs

*   **Alphabet scope:** this bitmask works for **lowercase aâ€“z** only (LeetCode constraint). For bigger alphabets, use a `Set<Character>` or a larger mask (e.g., 52 for upper/lower; `long` if â‰¤ 64 symbols).
*   **Order of ops:** when you detect a repeat, **increment `ans` and reset** *before* setting the current bit (you did this correctly).
*   **Empty string:** if inputs could be empty, returning `0` is more natural; LeetCode ensures `|s| â‰¥ 1`, so `ans = 1` is fine.
*   **Alternative form:** a `HashSet<Character>` with `if (seen.contains(c)) { ans++; seen.clear(); } seen.add(c);` is equivalent but a bit slower.

### ğŸ¤ 1-Sentence Pitch

*   â€œGreedily scan leftâ€‘toâ€‘right and start a new chunk whenever a char would duplicate in the current chunk; a 26â€‘bit mask gives constantâ€‘time membership for an optimal `O(N)` solution.â€
