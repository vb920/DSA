# 451. Sort Characters By Frequency

ğŸ” Iteration 1

**Pattern:** Hashing + Heap (Bucket sort alternative)

**Difficulty:** Medium

**Time:** 7m

**Solo:** Y nearâ€‘optimal

### ğŸ§  Core Logic

*   **The Trick:** count character frequencies, then **emit characters in descending frequency** (max-heap is straightforward; bucket sort is linear-time)
*   **Execution:**
    1.  build a frequency map `ch â†’ count`
    2.  push all entries into a **maxâ€‘heap** ordered by `count`
    3.  while heap not empty: pop `(ch, cnt)` and append `ch` **`cnt` times** to a `StringBuilder`
    4.  return the built string
*   **Complexity:**

Time `O(n + m log m)` with heap (n = length of string, m = distinct chars); **or** `O(n)` with bucket sort

Space `O(m)` (heap/map); **or** `O(n)` for buckets sized by max frequency

### ğŸš¨ Traps & Bugs

*   **Edge Case:** empty string â†’ empty result; tie order between same-frequency chars is **unspecified** (both heap and buckets are fine)
*   **Comparator overflow:** prefer `Integer.compare(e2.getValue(), e1.getValue())` over subtraction; counts â‰¤ `n`, so overflow is unlikely but best practice
*   **Unicode caution:** your code counts Java `char` (UTFâ€‘16 code units). For full Unicode correctness, iterate **code points**; LeetCode usually uses ASCII/letters, so this is fine
*   **Efficiency nits:** pre-size `StringBuilder` to `s.length()`; you can also use `ans.append(String.valueOf(ch).repeat(cnt))` (Java 11+) for clarity
*   **My Bugs:** none in logic; **missed alternative:** **bucket sort by frequency** (array of lists indexed by count) gives **`O(n)`** time and often simpler constants

### ğŸ¤ 1-Sentence Pitch

*   â€œCount frequencies, then output characters in descending countâ€”use a maxâ€‘heap for a clean `O(n + m log m)` or bucket sort to hit `O(n)`.â€
