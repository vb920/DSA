# 922. Sort Array By Parity II
**Pattern:** Two Pointers | **Difficulty:** Easy | **Time:** 5m | **Solo:** Y (Brute) / N (Optimal)

### ðŸ§  Core Logic
* **The Trick:** We don't need extra space. Just use one pointer for even *indices* (0, 2...) and one for odd *indices* (1, 3...). 
* **Execution:**
  1. Set even pointer `i = 0`, odd pointer `j = 1`.
  2. If `nums[i]` is even, it's correct -> move `i += 2`.
  3. If `nums[j]` is odd, it's correct -> move `j += 2`.
  4. If both are misaligned (even index has odd num, odd index has even num) -> Swap them!
* **Complexity:** Time `O(N)` | Space `O(1)`

### ðŸš¨ Traps & Bugs
* **Edge Case:** Keep the `while` loop condition strictly within bounds: `while (i < n && j < n)`.
* **My Bugs:** Got stuck on `O(N)` space. Also, used `k++` twice in brute force instead of `k += 2`, which is prone to indexing errors.

### ðŸŽ¤ 1-Sentence Pitch
* "My brute force used an extra array for `O(N)` space. We optimize to `O(1)` space using **Two Pointers**â€”one tracking even indices and one tracking odd indicesâ€”and swapping the elements whenever both point to the wrong parity."

---
